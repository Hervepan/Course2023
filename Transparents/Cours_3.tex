\documentclass[compress,10pt,aspectratio=169]{beamer}
\usetheme[customnumbering]{onera}

\usepackage{amsmath,amsfonts,graphicx}
\usepackage{pifont}
\usepackage{etoolbox}
\usepackage{multicol}
\usepackage{anyfontsize}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{fancybox}
\usepackage{colortbl}
\usepackage{tcolorbox}
%\setlength{\columnseprule}{1pt}
%\def\columnseprulecolor{\color{blue}}
\usepackage{minted} % syntax coloring. 
\setminted{encoding=utf-8, autogobble}
\usemintedstyle{xcode}
\AtBeginEnvironment{minted}{\fontsize{7}{7}\selectfont}

%\usepackage{dsfont}
\usepackage{ifdraft}
\ifdraft{
  \usepackage{fancyvrb}
  \DefineVerbatimEnvironment{cppcode}{Verbatim}{}
}{
\newminted{cpp}{}
}
\usepackage{hyperref}
\usetikzlibrary{shadows, arrows, decorations.pathmorphing, fadings, shapes.arrows, positioning, calc, shapes, fit, matrix,math}

\definecolor{lightblue}{RGB}{0,200,255} 
\definecolor{paper}{RGB}{255,247,197}
\definecolor{ocre}{RGB}{243,102,25} % Define the orange color used for highlighting throughout the book
\definecolor{BurntOrange}{RGB}{238,154,0}
\definecolor{darkorange}{RGB}{119, 77, 0}
\definecolor{OliveGreen}{RGB}{188,238,104}
\definecolor{DarkGreen}{RGB}{0,128,0}
\definecolor{BrickRed}{RGB}{238,44,44}
\definecolor{Tan}{RGB}{210,180,140}
\definecolor{Aquamarine}{RGB}{127,255,212}
\definecolor{NavyBlue}{RGB}{0,64,128}
\definecolor{DarkYellow}{RGB}{192,192,0}
\definecolor{Yellow}{RGB}{255,255,0}

\title[Parallel programming\hspace{2em}]{Parallel sorting algorithms}
\subtitle{Theory and implementation}
\author[X. JUVIGNY]{Xavier JUVIGNY, SN2A, DAAA, ONERA\\ \href{mailto:xavier.juvigny@onera.fr}{\texttt{xavier.juvigny@onera.fr}} }
\date[01/08/2023]{Course Parallel Programming\\- January 8th 2023 -}
\institute{\inst{1}ONERA,\inst{2}DAAA}

\AtBeginSection[]{
  \begin{frame}{Overview}
  \begin{multicols}{2}
  \small \tableofcontents[currentsection, hideallsubsections]
  \end{multicols}
  \end{frame} 
}


\begin{document}

\MakeTitlePage

\begin{frame}
\frametitle{Table of contents}
\begin{multicols}{2}
\tableofcontents[hideallsubsections]
\end{multicols}
\end{frame}

\section{Theory of parallel sorting algorithms}

\begin{frame}[fragile]{Complexity of sorting algorithms}
  \scriptsize
  \begin{block}{Basic operations}
    \begin{itemize}
    \item \textbf{Compare algorithm} : Comparaison algorithm complexity is supposed $\mathcal{O}(1)$. But in distributed parallel context, one must consider the distribution of the initial data
      to insert the cost of data exchange between processes !
    \item  \textbf{Exchange algorithm} : Exchange algorithm complexity is supposed $\mathcal{O}(1)$. But same consideration to do as \textbf{compare algorithm};
    \item Sequential ``compare--and--exchange'' algorithm:
\begin{minted}{C++}
if (a>b) { // Comparaison
  // Exchange
  tmp = a;
  a   = b;
  b   = tmp;   }
\end{minted}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Potential speed-up}
  \scriptsize
\begin{multicols}{2}
  \begin{center}
    Data \textbf{and} processes are sorted \\

\begin{tikzpicture}[scale=0.5]
\draw[fill=blue] (0,0) ellipse (3cm and 1cm);
\shade[ball color=red] (-1.5, -0.2) circle (2mm);
\shade[ball color=red] (-0.5, 0.2) circle (2mm);
\shade[ball color=red] (-0.9, 0.3) circle (2mm);
\shade[ball color=red] (0.3, -0.1) circle (2mm);
\shade[ball color=red] (0.6, 0.2) circle (2mm);
\shade[ball color=red] (2.1, 0) circle (2mm);
\shade[ball color=red] (-2.5, -0.1) circle (2mm);
\shade[ball color=red] (-1.75, 0.4) circle (2mm);
\shade[ball color=red] (-0.1, -0.7) circle (2mm);
\shade[ball color=red] (0.2, 0.6) circle (2mm);
\shade[ball color=red] (1.4, 0.5) circle (2mm);
\shade[ball color=red] (1.2, -0.6) circle (2mm);
\draw[color=black] (0,-1.25) node {\scriptsize Unsorted data};
\draw[->] (0,-1.5) -- ( 0,-2);
\draw[fill=blue] (-3.75,-2) rectangle (-2.25,-3);
\draw[fill=blue] (-1.75,-2) rectangle (-0.25,-3);
\draw[fill=blue] (0.25,-2) rectangle (1.75,-3);
\draw[fill=blue] (2.25,-2) rectangle (3.75,-3);
\shade[ball color=red] (-3.5, -2.2) circle (2mm);
\shade[ball color=red] (-3., -2.8) circle (2mm);
\shade[ball color=red] (-2.5, -2.3) circle (2mm);
\shade[ball color=red] (-1.5, -2.7) circle (2mm);
\shade[ball color=red] (-0.75, -2.2) circle (2mm);
\shade[ball color=red] (-0.5, -2.6) circle (2mm);
\shade[ball color=red] (+0.5, -2.75) circle (2mm);
\shade[ball color=red] (+0.75, -2.2) circle (2mm);
\shade[ball color=red] (+1.25, -2.8) circle (2mm);
\shade[ball color=red] (+2.5, -2.2) circle (2mm);
\shade[ball color=red] (+3., -2.6) circle (2mm);
\shade[ball color=red] (+3.5, -2.4) circle (2mm);
\draw[color=black] (0,-3.25) node {\scriptsize$\frac{N}{P}$ distributed data };
\draw[->] (0,-3.5) -- ( 0,-4);
\draw[fill=blue] (-3.75,-4) rectangle (-2.25,-5);
\draw[fill=blue] (-1.75,-4) rectangle (-0.25,-5);
\draw[fill=blue] (0.25,-4) rectangle (1.75,-5);
\draw[fill=blue] (2.25,-4) rectangle (3.75,-5);
\shade[ball color=red] (-3.5, -4.5) circle (2mm) node {\scriptsize 1};
\shade[ball color=red] (-3., -4.5) circle (2mm) node {\scriptsize 2};
\shade[ball color=red] (-2.5, -4.5) circle (2mm) node {\scriptsize 3};
\shade[ball color=red] (-1.5, -4.5) circle (2mm) node {\scriptsize 1};
\shade[ball color=red] (-1., -4.5) circle (2mm) node {\scriptsize 2};
\shade[ball color=red] (-0.5, -4.5) circle (2mm) node {\scriptsize 3};
\shade[ball color=red] (+0.5, -4.5) circle (2mm) node {\scriptsize 1};
\shade[ball color=red] (+1., -4.5) circle (2mm) node {\scriptsize 2};
\shade[ball color=red] (+1.5, -4.5) circle (2mm) node {\scriptsize 3};
\shade[ball color=red] (+2.5, -4.5) circle (2mm) node {\scriptsize 1};
\shade[ball color=red] (+3., -4.5) circle (2mm) node {\scriptsize 2};
\shade[ball color=red] (+3.5, -4.5) circle (2mm) node {\scriptsize 3};
\draw (-3,-5.25) node {\scriptsize$P_{1}$};
\draw (-2,-5.25) node {\scriptsize$<$};
\draw (-1,-5.25) node {\scriptsize$P_{2}$};
\draw (+0,-5.25) node {\scriptsize$<$};
\draw (+1,-5.25) node {\scriptsize$P_{3}$};
\draw (+2,-5.25) node {\scriptsize$<$};
\draw (+3,-5.25) node {\scriptsize$P_{4}$};
\draw[color=black] (0,-5.75) node {\scriptsize Data \textbf{and} processes sorted};
\end{tikzpicture}
\end{center}

\begin{itemize}
\item Best sequential sorting algorithms ( for arbitrary sequences of numbers )
  have average time complexity $O(n\log n)$
\item hence, the best speedup one can except from using $n$ processors is
$
\frac{O\left(n\log n\right)}{n} = O(\log n)
$
\item there are such parallel algorithms, but the hidden constant is very large ( F. Thomson Leighton : Introduction to parallel algorithms and architectures (1991) )
\item Generally, a pratical useful $O(\log n)$ algorithm may be difficult to find.
\end{itemize}
\end{multicols}

\alert{Beware}, it may be a bad idea to take $n$ processes to sort $n$ data (granularity).
\end{frame}

\begin{frame}[fragile]{Parallelization of a naive algorithm}
  \scriptsize
  \begin{block}{Naive algorithm}
  \begin{itemize}
  \item Count the number of numbers that are smaller than a number $a$ in the list
  \item this gives the position of $a$ in the sorted list
  \item this procedure has to be repeated for all elements of the list; hence the
        time complexity is $n(n-1)=O(n^{2})$ ( not so good sequential algorithm )
  \end{itemize}
  \end{block}

  \begin{exampleblock}{Implementation}
    \begin{center}
      \shadowbox{
        \begin{minipage}{0.5\textwidth}
\begin{minted}{C++}
for ( i = 0; i < n; i++ ) {// For each value
  x = 0;
  for ( j = 0; j < n; j++ )// Computing the new pos.
    if (a[i] > a[j]) x++;
  b[x] = a[i];
}
\end{minted}
        \end{minipage}
      }
    \end{center}
  \end{exampleblock}

  Work well if there are no repetitions of the numbers in the list ( in the case
  of repetitions one has to change slightly the code ).

\end{frame}


\begin{frame}[fragile]{Rank sort : Parallel code}
  \scriptsize
  \begin{exampleblock}{Embarrasingly ``ideal'' algorithm} 
    Parallel code, using $n$ processes ( for $n$ values to sort )

    \begin{center}
      \shadowbox{
        \begin{minipage}{0.5\textwidth}
          \begin{minted}{C++}
x = 0;
for ( j = 0; j < n; j++ )
  if ( a[rank] > a[j] ) x++;
b[x] = a[rank];
          \end{minted}
        \end{minipage}
      }
    \end{center}
    \end{exampleblock}

  \begin{block}{Complexity}
    \begin{itemize}
    \item $n$ processors work in parallel to find the ranks of all numbers of the list;
    \item Parallel time complexity is $O(n)$, better than any sequential sorting algorithm !
    \item Usable for GPGPU units.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{More parallelization\ldots}
  \scriptsize
  \begin{center}
    \textcolor{blue}{\bf Parallel code using $n^{2}$ processes ( for $n$ values to sort )}
  \end{center}
  \begin{block}{Parallel algorithm}
    \begin{itemize}
    \item In the case $n^{2}$ processes may be used, the comparison of each
      \texttt{a[0],\ldots,a[n-1]} with \texttt{a[i]} may be done in parallel as well
    \item Incrementing the counter is still sequential, hence the overall computation requires $1+n$ steps;
    \item If a tree structure is used to increment the counter, then the overall
      computation time is $O(\log_{2} n)$
      \begin{multicols}{2}
        
      \begin{minipage}{0.4\textwidth}
      \begin{tikzpicture}
        \node[draw] (A) at (0,0)  {1};
        \node[draw] (B) at (1,0)  {2};
        \node[draw] (C) at (2,0)  {3};
        \node[draw] (D) at (3,0) {-1};

        \node[draw] (E) at (0.5,1) {2};
        \node[draw] (F) at (2.5,1) {3};
%
        \node[draw] (G) at (1.5,2) {3};
%
        \draw[blue] (A) -- (B) node[midway,above,sloped] (AB) {\tiny\textcolor{red}{\bf max}};
        \draw[blue] (C) -- (D) node[midway,above,sloped] (CD) {\tiny\textcolor{red}{\bf max}};
        \draw[blue,->] (AB) -- (E);
        \draw[blue,->] (CD) -- (F);
%
        \draw[blue] (E) -- (F) node[midway,above,sloped] (EF) {\tiny\textcolor{red}{\bf max}};
        \draw[blue,->] (EF) -- (G);
      \end{tikzpicture}
      \end{minipage}

      ( but, as one expects, processor efficiency
      is very low )\\[2mm]
      There are just theorical results : it is not efficient to use $n$ or $n^{2}$
      processors to sort $n$ numbers.
      \end{multicols}
      
      \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Data partitionning}
  \scriptsize
  \begin{block}{\small Context}
    \begin{itemize}
    \item Usually the number $n$ of values is much larger than the number $p$ of processes;
    \item In such cases, each process will handle a part of the data (a sublist of the data)
    \end{itemize}
  \end{block}

  \begin{alertblock}{\small Distributed sorted container}
    \begin{itemize}
    \item local container is sorted;
    \item if $p_{i}<p_{j}$ then
      $\forall a_{i}\in p_{i}, \forall a_{j}\in p_{j}, a_{i} \leq a_{j}$
    \end{itemize}
  \end{alertblock}
  
  \begin{exampleblock}{\small Global scheme of parallel sort algorithm}
    For a process :
    \begin{itemize}
    \item Sort his local data;
    \item Run a merge sort algorithm to concatenate its list with that received from another process;
    \item Keep the bottom half (or the top half) of the sorted list.
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Parallel compare and exchange operations}
  \scriptsize
  \begin{block}{\small Asymmetric algorithm}
    \begin{itemize}
    \item Process $p_{i}$ sends local value $A$ to process $p_{j}$;
    \item Process $p_{j}$ compares value $A$ with some local values $B_{j}$;
    \item Send the $B_{j}$ which are larger (or lesser) than $A$. If none $B_{j}$ is larger (or lesser) than $A$, sends back $A$;
    \end{itemize}
  \end{block}

  \begin{block}{\small Symmetric algorithm}
    \begin{itemize}
    \item Processes $p_{i}$ and $p_{j}$ sends some value to the other;
    \item Each process compares his value with the received value;
    \item Each process keeps his value or the received value relative to the comparaison result;
    \end{itemize}
  \end{block}

  
  \begin{alertblock}{\small Remarks}
    \begin{itemize}
    \item Data exchanges between processes is very expensive, so find some algorithms which minimize data exchanges;
    \item Generally, the receive operation doesn't know the number of values to receive $\Rightarrow$ one must probe the
          received message to get the number of data to receive, allocate the relative buffer and receive the data !
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Scheme of a general algorithm for parallel sort algorithm}

\begin{figure}
\begin{tikzpicture}
\draw node[color=red] at (-2,2) {$P_{1}$};
\draw[->] (0,2) node[left] {\scriptsize $\begin{array}{|l|}\hline
                                            25 \\ \hline
                                            28 \\ \hline
                                            50 \\ \hline
                                            88 \\ \hline \end{array}$} -- 
                                        node[above,color=blue]{\scriptsize Merge sort}
                         (2,2) node {\scriptsize $\begin{array}{|l|}\hline
                             25 \\ \hline
                             28 \\ \hline
                             42 \\ \hline
                             43 \\ \hline
                             50 \\ \hline
                             80 \\ \hline
                             88 \\ \hline
                             98 \\ \hline \end{array}$} --
                         node[above,color=blue]{\scriptsize Keep lower numbers}
                         (8,2) node[right] {\scriptsize $\begin{array}{|l|}\hline
                                            25 \\ \hline
                                            28 \\ \hline
                                            42 \\ \hline
                                            43 \\ \hline \end{array}$};
\draw node[color=red] at (-2,-2) {$P_{2}$};
\draw[->] (0,-2) node[left] {\scriptsize $\begin{array}{|l|}\hline
                                            42 \\ \hline
                                            43 \\ \hline
                                            80 \\ \hline
                                            98 \\ \hline \end{array}$} -- 
                                        node[above,color=blue]{\scriptsize Merge sort}
                                        (2,-2) node {\scriptsize $\begin{array}{|l|}\hline
                             25 \\ \hline
                             28 \\ \hline
                             42 \\ \hline
                             43 \\ \hline
                             50 \\ \hline
                             80 \\ \hline
                             88 \\ \hline
                             98 \\ \hline \end{array}$} --
                         node[above,color=blue]{\scriptsize Keep upper numbers}
                         (8,-2) node[right] {\scriptsize $\begin{array}{|l|}\hline
                                            50 \\ \hline
                                            80 \\ \hline
                                            88 \\ \hline
                                            98 \\ \hline \end{array}$};
\draw[<->,color=red] (-0.5,-1) -- node[above, rotate=90]{\scriptsize send/recv} (-0.5,1);
\end{tikzpicture}
\end{figure}
\end{frame}

\section{Parallel sort algorithms}

\begin{frame}[fragile]{Sequential bubble sort algorithm}
  \scriptsize
  \begin{multicols}{2}
  \begin{block}{Bubble sort algorithm}
    \begin{itemize}
    \item Simplest, but not so efficient sequential sorting algorithm;
    \item Compare/exchange complexity :\\
      $\displaystyle
      \sum_{i=1}^{n-1}i = \frac{n(n-1)}{2} = O(n^{2})
      $
    \end{itemize}
  \end{block}

  \begin{figure}[h]
    \includegraphics[width=0.5\linewidth]{../Images/bulles.jpg}
    \caption{Analogic bubble sort}
  \end{figure}
  \end{multicols}
  
  \begin{exampleblock}{Sequential code}
    \begin{minted}{C++}
for (int i=n-1; i>0; --i)
    for (int j=0; j<i; ++j) {
      k = j+1;
      if (a[j]>a[k]) std::swap(a[j],a[k]);
    }
    \end{minted}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Odd-Even sort algorithm}
  \scriptsize
  \begin{itemize}
  \item Parallelized bubble sort
  \item Based on idea that the bodies of the main loop may be overlapped
  \end{itemize}

  \begin{exampleblock}{\small ``scalar'' Algorithm : Iteration between even and odd phase}
    \begin{itemize}
    \item Even phase\hspace*{2cm} \tikz{\node[draw,circle,inner sep=0pt] at (0,0) (A) {\scriptsize 0};\node[draw,circle,inner sep=0pt] at (1,0) (B) {\scriptsize 1};
      \node[draw,circle,inner sep=0pt] at (2,0) (C) {\scriptsize 2};\node[draw,circle,inner sep=0pt] at (3,0) (D) {\scriptsize 3};
      \draw[red,<->] (A) -- (B); \draw[red,<->] (C) -- (D);} 
      \begin{multicols}{2}
        \begin{tcolorbox}[boxsep=-1mm]
          \begin{minted}{C++}
if (rank%2==0) {
  recv(&temp, (rank+1)%nbp);
  send(&value,(rank+1)%nbp);
  if (temp < A) A = temp;   }
        \end{minted}
        \end{tcolorbox}
        
        \begin{tcolorbox}[boxsep=-1mm]
        \begin{minted}{C++}
if (rank%2==1) {
  send(&value,rank-1);
  recv(&temp, rank-1);
  if (temp > A) A = temp;   }
        \end{minted}
        \end{tcolorbox}
      \end{multicols}
    \item Odd phase\hspace*{2cm} \tikz{\node[draw,circle,inner sep=0pt] at (0,0) (A) {\scriptsize 0};\node[draw,circle,inner sep=0pt] at (1,0) (B) {\scriptsize 1};
      \node[draw,circle,inner sep=0pt] at (2,0) (C) {\scriptsize 2};\node[draw,circle,inner sep=0pt] at (3,0) (D) {\scriptsize 3};
      \draw[red,<->] (B) -- (C); \draw[red,dashed, <->] (A) -- (0,0.25) -- (3,0.25) -- (D);} 
      \begin{multicols}{2}
        \begin{tcolorbox}[boxsep=-1mm]
          \begin{minted}{C++}
if (rank%2==0) {
  recv(&temp, (rank+nbp-1)%nbp);
  send(&value,(rank+nbp-1)%nbp);
  if (temp > A) A = temp;   }
          \end{minted}
        \end{tcolorbox}

        \begin{tcolorbox}[boxsep=-1mm]
          \begin{minted}{C++}
if (rank%2==1) {
  send(&value,(rank+1)%nbp);
  recv(&temp, (rank+1)%nbp);
  if (temp < A) A = temp;   }
        \end{minted}
        \end{tcolorbox}
      \end{multicols}
    \end{itemize}
    
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Example of even--odd parallel bubble sort}

\alert{Example : Sorting 8 numbers on 8 processes}

{\small
\begin{tabular}{c|p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}p{2mm}}
Step & $P_{0}$ & & $P_{1}$ & & $P_{2}$ & & $P_{3}$ & & $P_{4}$ &
     & $P_{5}$ & & $P_{6}$ & & $P_{7}$ \\ \hline
 0   & 4 & \textcolor{red}{$\leftrightarrow$} & 2 & & 7 & \textcolor{red}{$\leftrightarrow$} & 8 & 
     & 5 & \textcolor{red}{$\leftrightarrow$} & 1 & & 3 & \textcolor{red}{$\leftrightarrow$} & 6 \\
 1   & 2 & & 4 & \textcolor{red}{$\leftrightarrow$} & 7 &
     & 8 & \textcolor{red}{$\leftrightarrow$} & 1 &
     & 5 & \textcolor{red}{$\leftrightarrow$} & 3 & & 6\\
 2   & 2 & \textcolor{red}{$\leftrightarrow$} & 4 & 
     & 7 & \textcolor{red}{$\leftrightarrow$} & 1 &
     & 8 & \textcolor{red}{$\leftrightarrow$} & 3 &
     & 5 & \textcolor{red}{$\leftrightarrow$} & 6 \\
 3   & 2 & 
     & 4 & \textcolor{red}{$\leftrightarrow$} & 1 &
     & 7 & \textcolor{red}{$\leftrightarrow$} & 3 &
     & 8 & \textcolor{red}{$\leftrightarrow$} & 5 &
     & 6 \\
 4   & 2 & \textcolor{red}{$\leftrightarrow$} & 1 & 
     & 4 & \textcolor{red}{$\leftrightarrow$} & 3 &
     & 7 & \textcolor{red}{$\leftrightarrow$} & 5 &
     & 8 & \textcolor{red}{$\leftrightarrow$} & 6 \\
 5   & 1 &
     & 2 & \textcolor{red}{$\leftrightarrow$} & 3 &
     & 4 & \textcolor{red}{$\leftrightarrow$} & 5 &
     & 7 & \textcolor{red}{$\leftrightarrow$} & 6 &
     & 8 \\
 6   & 1 & \textcolor{red}{$\leftrightarrow$} & 2 &
     & 3 & \textcolor{red}{$\leftrightarrow$} & 4 &
     & 5 & \textcolor{red}{$\leftrightarrow$} & 6 &
     & 7 & \textcolor{red}{$\leftrightarrow$} & 8 \\
 7   & 1 &
     & 2 & \textcolor{red}{$\leftrightarrow$} & 3 &
     & 4 & \textcolor{red}{$\leftrightarrow$} & 5 &
     & 6 & \textcolor{red}{$\leftrightarrow$} & 7 &
     & 8
\end{tabular}
}
\end{frame}

\begin{frame}[fragile]{Odd-even parallel algorithm per block}
  \scriptsize
  \begin{multicols}{2}
  \begin{block}{\small Per block algorithm}
    \begin{itemize}
    \item Replace a value per process with a sorted \\
          set of values per process
    \item Use sort-fusion algorithm to exchange values
    \item Data comparaison complexity : \\
      $
      \frac{N}{nbp}\log_{2}\left(\frac{N}{nbp}\right) +
      (nbp-1).\frac{2N}{nbp}
      $
    \item Data communication complexity : \\
      $
      (nbp-1).\frac{2N}{nbp}
      $
    \end{itemize}
  \end{block}

  \begin{exampleblock}{\small Implementation}
    \begin{minted}{C++}
sort(values);// Quick sort of local values
for (it=0; it<nbp-1; ++it) {// Odd-even algorithm
  if (it is odd) {
    if (rank is even and rank > 0) {
      receive(buffer, rank-1); send(values, rank-1);
      values = fusionSort(buffer, values, keepMax);
    } else if (rank is odd and rank < nbp-1) {
      send(values, rank+1); recv(buffer, rank+1);
      values = fusionSort(buffer, values, keepMin);
    }
  } else if (it is even) {
    if (rank is even and rank < nbp-1) {
      recv(buffer, rank+1); send(values, rank+1);
      values = fusionSort(buffer, values, keepMin);
    } else if (rank is odd) {
      send(values, rank-1); recv(buffer, rank-1);
      values = fusionSort(buffer, values, keepMax);
    }
  }
}
    \end{minted}
  \end{exampleblock}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]{Shear sort algorithm}
  \scriptsize
  \begin{center}{\small Two dimensional sorting}\end{center}

  \begin{block}{\small Basic idea}
    \begin{itemize}
    \item Look at the array as a two-dimensional array (one row per process)
    \item The goal is to sort this 2D array in snakelike style : even rows increasing, odd rows decreasing;
    \item Two phases : In \textbf{even phase}, sort per row,
      in {odd phase,}, sort per column increasing from top to bottom;
    \item After $\log_{2}(N)+1$ phases, the array is snakelike-style sorted.
    \end{itemize}
  \end{block}

  \begin{multicols}{2}
  \begin{exampleblock}{Example}
    \only<1>{
\begin{tabular}{cccc}
 4  & 14 & 8  & 2  \\
 10 & 3  & 13 & 16 \\
 7  & 15 & 1  & 5  \\
 12 & 6  & 11 & 9
\end{tabular}
{\small\color{blue} Original number}}
    \only<2>{
\begin{tabular}{cccc}
 2  & 4  & 8  & 14 \\
 16 & 13 & 10 & 3  \\
 1  & 5  & 7  & 15 \\
 12 & 11 & 9  & 6
\end{tabular}
{\small\color{blue} Phase 1 -- row sort} }
    \only<3>{
\begin{tabular}{cccc}
 1  & 4  & 7  & 3  \\
 2  & 5  & 8  & 6  \\
 12 & 11 & 9  & 14 \\
 16 & 13 & 10 & 15
\end{tabular}
{\small\color{blue} Phase 2 -- col sort} }
    \only<4>{
\begin{tabular}{cccc}
1  & 3  & 4  & 7  \\
8  & 6  & 5  & 2  \\
9  & 11 & 12 & 14 \\
16 & 15 & 13 & 10
\end{tabular}
    {\small\color{blue} Phase 3 : row sort}
    }
    \only<5>{
\begin{tabular}{cccc}
1  & 3  & 4  & 2  \\
8  & 6  & 5  & 7  \\
9  & 11 & 12 & 10 \\
16 & 15 & 13 & 14
\end{tabular}
{\small\color{blue} Phase 4 : col sort} }
    \only<6>{
\begin{tabular}{cccc}
1  & 2  & 3  & 4  \\
8  & 7  & 6  & 5  \\
9  & 10 & 11 & 12 \\
16 & 15 & 14 & 13
\end{tabular}
{\small\color{blue} Final 5 : row sort} }
  \end{exampleblock}

  \begin{alertblock}{Remarques}
\begin{itemize}
    \item Embarrassingly parallel algorithm for shared memory !
    \item But not well adapted for distributed parallel architecture as is;
    \item How change this algorithm for distributed parallel architecture ?
\end{itemize}
  \end{alertblock}
\end{multicols}
\end{frame}

\begin{frame}[fragile]{Shear sort algorithm for parallel distributed memory architecture}
    \scriptsize
    \begin{center}\textcolor{blue}{\small Implementation ideas}\end{center}
    
    \begin{itemize}
        \item Same principal as odd-even algorithm : replace a value with some sets of values $S_{i}$ (one set per process);
        \item Define a relation order : $S_{i} < S_{j}$ iff $\max({S_{i}}) < \min({S_{j}})$ (In set, values ordered as increasing order)
        \item Use odd-even algorithm to parallelize the phase of sorting per row or column;
        \item Grouping processes in new communicators per rows and per columns;
        \item Play with rank numbering to alternate between increasing order and decreasing order for rows;
    \end{itemize}

    \begin{block}{\small Processes repartition}
    \begin{multicols}{2}
    \begin{minipage}{0.5\textwidth}
        \begin{figure}
            \begin{tikzpicture}
\draw[fill=cyan] (0.9, 0) ellipse  (1.5 and 0.25);
\draw[fill=cyan] (0.9, -0.6) ellipse  (1.5 and 0.25);
\draw[fill=cyan] (0.9, -1.2) ellipse  (1.5 and 0.25);
\draw[fill=cyan] (0.9, -1.8) ellipse  (1.5 and 0.25);
\draw[fill=green,opacity=0.5] (0, -0.9) ellipse  (0.25 and 1.5);
\draw[fill=green,opacity=0.5] (0.6, -0.9) ellipse  (0.25 and 1.5);
\draw[fill=green,opacity=0.5] (1.2, -0.9) ellipse  (0.25 and 1.5);
\draw[fill=green,opacity=0.5] (1.8, -0.9) ellipse  (0.25 and 1.5);
\foreach \x/\y/\r in {0/0/0, 0/1/1, 0/2/2, 0/3/3, 1/0/7, 1/1/6, 1/2/5, 1/3/4, 2/0/8, 2/1/9, 2/2/10, 2/3/11, 3/0/15, 3/1/14, 3/2/13, 3/3/12} 
{
    \node[draw, circle, inner sep=1pt] (P\r) at (0.6*\y,-0.6*\x) {\tiny $P_{\r}$};
}
\foreach \x [evaluate=\x as \y using {int(\x-1)}] in {1,...,15} {
    \draw[red, ->, thick] (P\y) -- (P\x);
}
\node[fill=cyan, ellipse] at (4.4, -0.6) {\tiny Row communicators};
\node[fill=green!50, ellipse] at (4.4, -1.2) {\tiny Column communicators};
            \end{tikzpicture}
        \end{figure}
    \end{minipage}

    \begin{minipage}{0.5\textwidth}
        \begin{itemize}
            \item Use \verb@MPI_Comm_split(comm,color,key,&newcomm)@ to define row and columns communicators;
            \item Processes calling this function with same color are inside the same new communicator;
            \item key is a value to numbering the processes inside the new communicator.
        \end{itemize}
    \end{minipage}
\end{multicols}
    \end{block}
\end{frame}

\end{document}
